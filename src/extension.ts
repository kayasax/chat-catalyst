import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';

// Global state management for proper cleanup
interface ExtensionState {
	isExecuting: boolean;
	activeTimers: NodeJS.Timeout[];
	tempFiles: string[];
	disposables: vscode.Disposable[];
}

export function activate(context: vscode.ExtensionContext) {
	console.log('üöÄ Chat Catalyst Enhanced with Long Prompt Support is now active!');

	// Initialize extension state for proper cleanup
	const state: ExtensionState = {
		isExecuting: false,
		activeTimers: [],
		tempFiles: [],
		disposables: []
	};

	// Helper to safely create timers that can be cleaned up
	function createManagedTimer(callback: () => void, delay: number): NodeJS.Timeout {
		const timer = setTimeout(() => {
			callback();
			// Remove timer from active list once it executes
			const index = state.activeTimers.indexOf(timer);
			if (index > -1) {
				state.activeTimers.splice(index, 1);
			}
		}, delay);
		state.activeTimers.push(timer);
		return timer;
	}
	// Helper to cleanup resources
	function cleanup() {
		console.log('üßπ Starting extension cleanup...');

		// Clear all active timers
		state.activeTimers.forEach(timer => clearTimeout(timer));
		state.activeTimers = [];
		console.log('‚úÖ Cleared all active timers');

		// Dispose all registered disposables
		state.disposables.forEach(disposable => {
			try {
				disposable.dispose();
			} catch (error) {
				console.log('Error disposing resource:', error);
			}
		});
		state.disposables = [];
		console.log('‚úÖ Disposed all event listeners');

		// Clean up temporary files (only on deactivation, not during normal operation)
		state.tempFiles.forEach(file => {
			try {
				if (fs.existsSync(file)) {
					fs.unlinkSync(file);
					console.log(`üßπ Cleaned up temp file: ${file}`);
				}
			} catch (error) {
				console.log(`Could not clean up temp file ${file}:`, error);
			}
		});
		state.tempFiles = [];
		console.log('‚úÖ Cleanup completed');
	}

	// Get extension configuration
	function getConfig() {
		return vscode.workspace.getConfiguration('chatCatalyst');
	}

	// Check if auto-injection is enabled and get the custom prompt
	function getAutoPrompt(): string | null {
		const config = getConfig();
		const enabled = config.get<boolean>('enabled', true);
		const autoPrompt = config.get<string>('autoPrompt', '');

		return enabled && autoPrompt ? autoPrompt : null;
	}

	// Create a context file for very long prompts
	async function createPromptContextFile(longPrompt: string): Promise<string | null> {
		try {
			const tempDir = path.join(os.tmpdir(), 'chat-catalyst-context');

			// Ensure temp directory exists
			if (!fs.existsSync(tempDir)) {
				fs.mkdirSync(tempDir, { recursive: true });
			}

			const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
			const contextFile = path.join(tempDir, `prompt-context-${timestamp}.md`);

			const formattedContent = `# üß† Chat Context for Session

**Generated:** ${new Date().toLocaleString()}
**Source:** Chat Catalyst Auto-Prompt

---

## Your Instructions

${longPrompt}

---

## Session Starter Template Reference

\`\`\`markdown
# üß† AI Session Starter: Project Memory
This file serves as the persistent memory for the AI assistant across sessions in this workspace. It should be updated regularly to reflect the current state, goals, and progress of the project.

---

## üìò Project Overview
**Project Name:** _Provide a short, descriptive name for the project._
**Description:** _A brief summary of what this project is about, its purpose, and key components._
**Primary Goals:**
- Goal 1
- Goal 2
- Goal 3

**Key Technologies / Tools:** _List any relevant frameworks, libraries, or platforms._

---

## üß† Assistant Memory
This section is maintained by the AI assistant to track important context and decisions across sessions.

**Current Understanding:** _Summary of what the assistant currently knows about the project._

**Known Constraints or Requirements:**
- Constraint 1
- Constraint 2

**Pending Questions / Clarifications:**
- Question 1
- Question 2

---

## üîÑ Update Log
| Date       | Summary of Update                          |
|------------|---------------------------------------------|
| YYYY-MM-DD | Initial project setup and context defined.  |

---

## ‚úÖ Next Steps
- [ ] Task 1
- [ ] Task 2
- [ ] Task 3

---

> _This file is automatically referenced and updated by the AI assistant to maintain continuity across sessions._
\`\`\`

---

*This context file was automatically generated by Chat Catalyst for better long-prompt handling.*
`;			fs.writeFileSync(contextFile, formattedContent);

			// Track temp file for cleanup ONLY on extension deactivation
			// Do NOT set immediate cleanup timers as they interfere with file references
			state.tempFiles.push(contextFile);

			console.log(`‚úÖ Temp context file created: ${contextFile}`);
			console.log(`üìå Temp file will be cleaned up only on extension deactivation`);

			return contextFile;
		} catch (error) {
			console.error('Failed to create context file:', error);
			return null;
		}
	}
	// Get relevant project files for context
	function getRelevantProjectFiles(): string[] {
		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			return [];
		}

		const relevantFiles: string[] = [];
		const basePath = workspaceFolder.uri.fsPath;

		// Check for Session_starter.md in current workspace first, then parent directory
		const sessionStarterPaths = [
			{ path: path.join(basePath, 'Session_starter.md'), ref: 'Session_starter.md' },
			{ path: path.join(basePath, '..', 'Session_starter.md'), ref: '../Session_starter.md' }
		];

		for (const { path: sessionPath, ref } of sessionStarterPaths) {
			console.log(`üîç Checking for Session_starter.md at: ${sessionPath}`);
			if (fs.existsSync(sessionPath)) {
				const stats = fs.statSync(sessionPath);
				console.log(`üìÑ Found Session_starter.md (${stats.size} bytes): ${ref}`);
				if (stats.size > 0) { // Only add if file has content
					relevantFiles.push(ref);
					console.log(`‚úÖ Added Session_starter.md to relevant files: ${ref}`);
					break;
				} else {
					console.log(`‚ö†Ô∏è Session_starter.md exists but is empty, skipping: ${ref}`);
				}
			}
		}
		// Common important files - ONLY add these if Session_starter.md was NOT found
		// This ensures Session_starter.md always has priority over README.md
		if (relevantFiles.length === 0) {
			console.log(`üìã No Session_starter.md found, adding other important files...`);
			const importantFiles = ['README.md', 'package.json', 'tsconfig.json'];
			for (const file of importantFiles) {
				const filePath = path.join(basePath, file);
				if (fs.existsSync(filePath)) {
					relevantFiles.push(file);
				}
			}
		} else {
			console.log(`üéØ Session_starter.md found - skipping other files to maintain priority`);
		}

		console.log(`üìÅ Final relevant files list: ${relevantFiles.join(', ')}`);
		return relevantFiles;
	}
	// Build rich context prompt with smart long-prompt handling
	async function buildSmartContextPrompt(autoPrompt: string): Promise<string> {
		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			return autoPrompt;
		}

		// Get relevant files first to check if Session_starter.md exists
		const relevantFiles = getRelevantProjectFiles();
		console.log(`ÔøΩ Found relevant files: ${relevantFiles.join(', ')}`);

		// Check if Session_starter.md exists and has content
		const sessionStarter = relevantFiles.find(f => f.includes('Session_starter.md'));

		// If we have Session_starter.md, use it instead of creating a context file
		if (sessionStarter) {
			console.log(`üìé Using existing Session_starter.md instead of creating context file`);
			let richPrompt = `#workspace #file:${sessionStarter} `;

			richPrompt += `

üéØ **Session Context Loaded**

I've attached your Session_starter.md file which contains the project context and instructions for this session. Please:

1. **Review the Session_starter.md file** for project overview and current state
2. **Follow the established patterns** and guidelines
3. **Update the session file** as we make progress
4. **Maintain project continuity** as described

Ready to help with your project! üöÄ`;

			console.log(`üéØ Session starter prompt generated (${richPrompt.length} chars)`);
			console.log(`ÔøΩ Prompt preview: ${richPrompt.substring(0, 200)}...`);
			return richPrompt;
		}

		// Check if prompt is very long (over 1000 characters) and no Session_starter.md exists
		if (autoPrompt.length > 1000) {
			console.log(`üîÑ Long prompt detected (${autoPrompt.length} chars) and no Session_starter.md found, creating context file...`);
			const contextFile = await createPromptContextFile(autoPrompt);
			if (contextFile) {
				console.log(`‚úÖ Context file created at: ${contextFile}`);
				try {
					// Try to get relative path to workspace, or use absolute path
					const workspacePath = workspaceFolder.uri.fsPath;
					let richPrompt = '#workspace ';

					// Add the context file (copy to workspace temp for attachment)
					const contextTimestamp = Date.now();
					const contextFileName = `context-${contextTimestamp}.md`;
					const workspaceContextFile = path.join(workspacePath, '.vscode', contextFileName);
					const vscodeDir = path.dirname(workspaceContextFile);

					if (!fs.existsSync(vscodeDir)) {
						console.log(`üìÅ Creating .vscode directory: ${vscodeDir}`);
						fs.mkdirSync(vscodeDir, { recursive: true });
					}

					console.log(`üìã Copying context file from: ${contextFile}`);
					console.log(`üìã Copying context file to: ${workspaceContextFile}`);

					try {
						fs.copyFileSync(contextFile, workspaceContextFile);
						console.log(`‚úÖ Context file copied successfully`);
					} catch (copyError) {
						console.error(`‚ùå Failed to copy context file:`, copyError);
						throw copyError;
					}

					// Verify the file was actually created
					if (!fs.existsSync(workspaceContextFile)) {
						console.error(`‚ùå Context file was not created at: ${workspaceContextFile}`);
						throw new Error('Context file creation verification failed');
					}
							richPrompt += `#file:.vscode/${contextFileName} `;

					// Track workspace context file for cleanup but DO NOT clean it up immediately
					// The file should persist for the entire chat session (24 hours)
					state.tempFiles.push(workspaceContextFile);

					console.log(`‚úÖ Context file created: .vscode/${contextFileName}`);
					console.log(`üìå Context file will persist for 24 hours to support #file: reference`);

					// Schedule cleanup after 24 hours ONLY - no immediate cleanup
					// This ensures the #file: reference remains valid for the entire session
					const cleanupTimer = createManagedTimer(() => {
						try {
							if (fs.existsSync(workspaceContextFile)) {
								fs.unlinkSync(workspaceContextFile);
								console.log(`üßπ Cleaned up context file after 24 hours: .vscode/${contextFileName}`);
								// Remove from tracked files
								const index = state.tempFiles.indexOf(workspaceContextFile);
								if (index > -1) {
									state.tempFiles.splice(index, 1);
								}
							}
						} catch (error) {
							console.log('Could not clean up workspace context file after 24 hours:', error);
						}
					}, 24 * 60 * 60 * 1000); // 24 hours

					console.log(`‚è∞ Cleanup timer set for 24 hours, timer ID: ${cleanupTimer}`);
					console.log(`üìÅ File will remain accessible at: .vscode/${contextFileName}`);					richPrompt += `

üéØ **Long Prompt Context Loaded**

I've attached a detailed context file with comprehensive instructions for this session. Please:

1. **Review the attached context file** for complete instructions
2. **Follow the step-by-step guidance** provided
3. **Use the session starter template** if creating new files
4. **Maintain continuity** as described in the instructions

Ready to help with your project! üöÄ`;

					console.log(`üéØ Final rich prompt generated (${richPrompt.length} chars)`);
					console.log(`üìã Prompt preview: ${richPrompt.substring(0, 200)}...`);
					return richPrompt;				} catch (error) {
					console.error('‚ùå Could not create workspace context file:', error);
					console.log('üîÑ Falling back to direct context inclusion...');					// Fallback: include context in prompt directly but with attachments
					const fallbackFiles = getRelevantProjectFiles();
					let fallbackPrompt = '#workspace ';

					// Add session starter if available - PRIORITIZE IT OVER ALL OTHER FILES
					const fallbackSessionStarter = fallbackFiles.find(f => f.includes('Session_starter.md'));
					if (fallbackSessionStarter) {
						fallbackPrompt += `#file:${fallbackSessionStarter} `;
						console.log(`üìé Attached session starter (PRIORITY): ${fallbackSessionStarter}`);
					} else {
						// Only add other files if Session_starter.md is NOT available
						const otherFallbackFiles = fallbackFiles.slice(0, 1); // Just one other file
						for (const file of otherFallbackFiles) {
							fallbackPrompt += `#file:${file} `;
							console.log(`üìé Attached fallback file: ${file}`);
						}
					}

					fallbackPrompt += `

‚ö†Ô∏è **Context File Attachment Failed**

The long prompt context file could not be attached due to: ${error}

**Original Instructions:**
${autoPrompt}

Ready to help with your project! üöÄ`;

					return fallbackPrompt;
				}
			}
		}
		// Fallback for shorter prompts or if context file creation fails
		let richPrompt = '#workspace ';
		const finalRelevantFiles = getRelevantProjectFiles();

		// Add session starter if available
		const finalSessionStarter = finalRelevantFiles.find(f => f.includes('Session_starter.md'));
		if (finalSessionStarter) {
			richPrompt += `#file:${finalSessionStarter} `;
		}
		// Add other important files (limit to avoid overload) - ONLY if we don't have Session_starter.md
		// Session_starter.md should be the ONLY file when available to maintain priority
		if (!finalSessionStarter) {
			const otherFiles = finalRelevantFiles.filter(f => !f.includes('Session_starter.md')).slice(0, 2);
			for (const file of otherFiles) {
				richPrompt += `#file:${file} `;
			}
		} else {
			console.log(`üéØ Session_starter.md found - skipping other files to maintain priority`);
		}

		richPrompt += '\n\n' + autoPrompt;
		return richPrompt;
	}

	// Function to clear existing text in chat input field
	async function clearChatInput(): Promise<boolean> {
		try {
			await vscode.commands.executeCommand('editor.action.selectAll');
			await new Promise(resolve => setTimeout(resolve, 50));
			await vscode.commands.executeCommand('deleteLeft');
			return true;
		} catch {
			try {
				await vscode.commands.executeCommand('deleteLeft');
				return true;
			} catch {
				return false;
			}
		}
	}

	// Enhanced injection function with smart prompt handling
	async function injectSmartPrompt(): Promise<boolean> {
		const autoPrompt = getAutoPrompt();
		if (!autoPrompt) { return false; }

		console.log(`üîÑ Processing prompt (${autoPrompt.length} characters)...`);

		try {
			let originalClipboard = '';
			try {
				originalClipboard = await vscode.env.clipboard.readText();
			} catch {
				// Ignore clipboard read errors
			}

			// Clear existing input
			const cleared = await clearChatInput();
			if (!cleared) {
				console.log('‚ö†Ô∏è Could not clear existing text, continuing anyway...');
			}

			await new Promise(resolve => setTimeout(resolve, 10));

			// Build smart context prompt (handles long prompts automatically)
			const smartPrompt = await buildSmartContextPrompt(autoPrompt);

			// Put smart prompt in clipboard
			await vscode.env.clipboard.writeText(smartPrompt);
			await new Promise(resolve => setTimeout(resolve, 10));

			// Inject the prompt
			try {
				await vscode.commands.executeCommand('type', { text: smartPrompt });
				console.log('‚úÖ Smart prompt injected successfully');
				vscode.window.setStatusBarMessage(
					smartPrompt.length > autoPrompt.length ?
					'‚úÖ Enhanced prompt with attachments injected!' :
					'‚úÖ Prompt injected!',
					3000
				);				// Restore clipboard after a short delay
				createManagedTimer(async () => {
					try {
						if (originalClipboard !== undefined) {
							await vscode.env.clipboard.writeText(originalClipboard);
							console.log('‚úÖ Clipboard restored');
						}
					} catch {
						// Ignore restore errors
					}
				}, 200);
				return true;
			} catch {
				// Fallback to paste
				try {
					await vscode.commands.executeCommand('editor.action.clipboardPasteAction');
					console.log('‚úÖ Smart prompt pasted successfully');
					vscode.window.setStatusBarMessage('‚úÖ Smart prompt pasted!', 2000);
					return true;
				} catch {
					console.log('‚ùå Both type and paste failed');
					return false;
				}
			}
		} catch (error) {
			console.error('‚ùå Smart injection failed:', error);
			vscode.window.setStatusBarMessage('‚ùå Injection failed', 2000);
			return false;
		}
	}
	// Register commands with proper disposable tracking
	const startChatCommand = vscode.commands.registerCommand('chatCatalyst.startChat', enhancedStartChat);

	// Other commands remain the same...
	const editPromptCommand = vscode.commands.registerCommand('chatCatalyst.editPrompt', async () => {
		const config = getConfig();
		const currentPrompt = config.get<string>('autoPrompt', '');

		const newPrompt = await vscode.window.showInputBox({
			prompt: 'Enter your auto-prompt for Copilot Chat',
			value: currentPrompt,
			placeHolder: 'Your default prompt...'
		});

		if (newPrompt !== undefined) {
			await config.update('autoPrompt', newPrompt, vscode.ConfigurationTarget.Global);
			vscode.window.showInformationMessage('‚úÖ Auto-prompt updated successfully!');
		}
	});

	const toggleCommand = vscode.commands.registerCommand('chatCatalyst.toggle', async () => {
		const config = getConfig();
		const currentEnabled = config.get<boolean>('enabled', true);
		await config.update('enabled', !currentEnabled, vscode.ConfigurationTarget.Global);
		vscode.window.showInformationMessage(`Chat Catalyst ${!currentEnabled ? 'enabled' : 'disabled'}!`);
	});

	// Add test command to verify extension is working
	const testCommand = vscode.commands.registerCommand('chatCatalyst.test', async () => {
		console.log('üß™ Test command executed!');
		vscode.window.showInformationMessage('‚úÖ Chat Catalyst extension is working! Check the console for logs.');

		// Test workspace detection
		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (workspaceFolder) {
			console.log(`üìÅ Workspace detected: ${workspaceFolder.uri.fsPath}`);
			const projectType = await detectProjectType();
			console.log(`üîç Project type detected: ${projectType}`);
			vscode.window.showInformationMessage(`Workspace: ${workspaceFolder.name}, Project Type: ${projectType}`);
		} else {
			vscode.window.showWarningMessage('No workspace folder detected!');
		}
	});

	// Add template editing commands
	const editCustomInstructionsCommand = vscode.commands.registerCommand('chatCatalyst.editCustomInstructions', async () => {
		await vscode.commands.executeCommand('workbench.action.openSettings', 'chatCatalyst.customInstructionsTemplate');
	});

	const editSessionStarterCommand = vscode.commands.registerCommand('chatCatalyst.editSessionStarter', async () => {
		await vscode.commands.executeCommand('workbench.action.openSettings', 'chatCatalyst.sessionStarterTemplate');
	});

	const resetTemplatesCommand = vscode.commands.registerCommand('chatCatalyst.resetTemplates', async () => {
		const result = await vscode.window.showWarningMessage(
			'Reset templates to default? This will overwrite your customizations.',
			{ modal: true },
			'Reset', 'Cancel'
		);
		
		if (result === 'Reset') {
			const config = vscode.workspace.getConfiguration('chatCatalyst');
			await config.update('customInstructionsTemplate', undefined, vscode.ConfigurationTarget.Global);
			await config.update('sessionStarterTemplate', undefined, vscode.ConfigurationTarget.Global);
			vscode.window.showInformationMessage('‚úÖ Templates reset to default!');
		}
	});

	// Track all disposables properly
	state.disposables.push(
		startChatCommand, 
		editPromptCommand, 
		toggleCommand, 
		testCommand,
		editCustomInstructionsCommand,
		editSessionStarterCommand,
		resetTemplatesCommand
	);
	context.subscriptions.push(
		startChatCommand, 
		editPromptCommand, 
		toggleCommand, 
		testCommand,
		editCustomInstructionsCommand,
		editSessionStarterCommand,
		resetTemplatesCommand
	);

	// Register cleanup to be called on deactivation
	const cleanupDisposable = {
		dispose: cleanup
	};
	context.subscriptions.push(cleanupDisposable);
	state.disposables.push(cleanupDisposable);

	// New Session Continuity Setup Functions

	// Check if custom instructions file exists
	async function checkCustomInstructions(): Promise<boolean> {
		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			return false;
		}

		const customInstructionsPath = path.join(workspaceFolder.uri.fsPath, '.github', 'copilot-instructions.md');
		return fs.existsSync(customInstructionsPath);
	}

	// Create custom instructions file for session continuity
	async function createCustomInstructions(): Promise<void> {
		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			return;
		}

		const githubDir = path.join(workspaceFolder.uri.fsPath, '.github');
		const customInstructionsPath = path.join(githubDir, 'copilot-instructions.md');

		// Ensure .github directory exists
		if (!fs.existsSync(githubDir)) {
			fs.mkdirSync(githubDir, { recursive: true });
		}

		// Get template from settings
		const config = vscode.workspace.getConfiguration('chatCatalyst');
		const templateContent = config.get<string>('customInstructionsTemplate', '');
		
		// Debug logging
		console.log('üîç Debug: Reading custom instructions template from settings...');
		console.log('üìù Template length:', templateContent.length);
		console.log('üìù Template starts with:', templateContent.substring(0, 100));
		
		// Apply template variables
		const projectName = path.basename(workspaceFolder.uri.fsPath);
		const projectType = await detectProjectType();
		const currentDate = new Date().toISOString().split('T')[0];
		
		console.log('üîß Variables:', { projectName, projectType, currentDate });
		
		const instructionsContent = templateContent
			.replace(/\{\{PROJECT_NAME\}\}/g, projectName)
			.replace(/\{\{PROJECT_TYPE\}\}/g, projectType)
			.replace(/\{\{DATE\}\}/g, currentDate);

		console.log('üìÑ Final content length:', instructionsContent.length);
		console.log('üìÑ Final content starts with:', instructionsContent.substring(0, 100));

		fs.writeFileSync(customInstructionsPath, instructionsContent);
		console.log(`‚úÖ Created custom instructions: ${customInstructionsPath}`);
	}

	// Detect project type based on files and structure
	async function detectProjectType(): Promise<string> {
		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			return 'general';
		}

		const basePath = workspaceFolder.uri.fsPath;

		// Check for specific project indicators
		if (fs.existsSync(path.join(basePath, 'package.json'))) {
			const packageJson = JSON.parse(fs.readFileSync(path.join(basePath, 'package.json'), 'utf8'));

			// Check for specific frameworks
			if (packageJson.dependencies?.react || packageJson.devDependencies?.react) {
				return 'react';
			}
			if (packageJson.dependencies?.next || packageJson.devDependencies?.next) {
				return 'nextjs';
			}
			if (packageJson.dependencies?.vue || packageJson.devDependencies?.vue) {
				return 'vue';
			}
			if (packageJson.dependencies?.angular || packageJson.devDependencies?.angular) {
				return 'angular';
			}
			if (packageJson.dependencies?.express || packageJson.devDependencies?.express) {
				return 'nodejs-express';
			}
			if (packageJson.dependencies?.vscode || packageJson.devDependencies?.vscode) {
				return 'vscode-extension';
			}

			return 'nodejs';
		}

		if (fs.existsSync(path.join(basePath, 'requirements.txt')) || fs.existsSync(path.join(basePath, 'pyproject.toml'))) {
			return 'python';
		}

		if (fs.existsSync(path.join(basePath, 'Cargo.toml'))) {
			return 'rust';
		}
		if (fs.existsSync(path.join(basePath, 'go.mod'))) {
			return 'go';
		}
		if (fs.existsSync(path.join(basePath, 'pom.xml')) || fs.existsSync(path.join(basePath, 'build.gradle'))) {
			return 'java';
		}
		if (fs.existsSync(path.join(basePath, '*.csproj')) || fs.existsSync(path.join(basePath, '*.sln'))) {
			return 'dotnet';
		}

		return 'general';
	}

	// Create Session_starter.md template based on project type
	async function createSessionStarter(projectType: string): Promise<void> {
		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			return;
		}

		const sessionStarterPath = path.join(workspaceFolder.uri.fsPath, 'Session_starter.md');
		if (fs.existsSync(sessionStarterPath)) {
			return; // Don't overwrite existing file
		}

		const projectName = path.basename(workspaceFolder.uri.fsPath);
		const currentDate = new Date().toISOString().split('T')[0];

		const sessionContent = generateSessionTemplate(projectName, projectType, currentDate);
		fs.writeFileSync(sessionStarterPath, sessionContent);
		console.log(`‚úÖ Created Session_starter.md for ${projectType} project: ${sessionStarterPath}`);
	}

	// Generate session template based on project type
	function generateSessionTemplate(projectName: string, projectType: string, date: string): string {
		const techStack = getTechStackForProjectType(projectType);
		const commonCommands = getCommonCommandsForProjectType(projectType);

		// Get template from settings
		const config = vscode.workspace.getConfiguration('chatCatalyst');
		const templateContent = config.get<string>('sessionStarterTemplate', '');
		
		// Prepare tech stack string
		const techStackString = techStack.technologies.map(tech => `- ${tech}`).join('\n');
		const commonCommandsString = commonCommands.map(cmd => `- \`${cmd}\``).join('\n');
		
		// Apply template variables
		return templateContent
			.replace(/\{\{PROJECT_NAME\}\}/g, projectName)
			.replace(/\{\{PROJECT_TYPE\}\}/g, techStack.type)
			.replace(/\{\{DATE\}\}/g, date)
			.replace(/\{\{TECH_STACK\}\}/g, techStackString)
			.replace(/\{\{COMMON_COMMANDS\}\}/g, commonCommandsString);
	}

	// Get technology stack information for project type
	function getTechStackForProjectType(projectType: string): { type: string; technologies: string[] } {
		const stacks: Record<string, { type: string; technologies: string[] }> = {
			'react': {
				type: 'React Web Application',
				technologies: ['React', 'JavaScript/TypeScript', 'HTML/CSS', 'Node.js', 'Webpack/Vite']
			},
			'nextjs': {
				type: 'Next.js Full-Stack Application',
				technologies: ['Next.js', 'React', 'TypeScript', 'Node.js', 'Vercel/SSR']
			},
			'vue': {
				type: 'Vue.js Web Application',
				technologies: ['Vue.js', 'JavaScript/TypeScript', 'HTML/CSS', 'Node.js', 'Vite']
			},
			'angular': {
				type: 'Angular Web Application',
				technologies: ['Angular', 'TypeScript', 'HTML/CSS', 'Node.js', 'Angular CLI']
			},
			'nodejs': {
				type: 'Node.js Application',
				technologies: ['Node.js', 'JavaScript/TypeScript', 'NPM/Yarn', 'Express/Fastify']
			},
			'nodejs-express': {
				type: 'Node.js Express Application',
				technologies: ['Node.js', 'Express.js', 'JavaScript/TypeScript', 'NPM/Yarn']
			},
			'vscode-extension': {
				type: 'VS Code Extension',
				technologies: ['TypeScript', 'VS Code Extension API', 'Node.js', 'Webpack']
			},
			'python': {
				type: 'Python Application',
				technologies: ['Python', 'pip/poetry', 'Virtual Environment', 'pytest']
			},
			'rust': {
				type: 'Rust Application',
				technologies: ['Rust', 'Cargo', 'rustc', 'Crates.io']
			},
			'go': {
				type: 'Go Application',
				technologies: ['Go', 'Go Modules', 'go build', 'go test']
			},
			'java': {
				type: 'Java Application',
				technologies: ['Java', 'Maven/Gradle', 'JUnit', 'Spring Framework']
			},
			'dotnet': {
				type: '.NET Application',
				technologies: ['.NET Core/Framework', 'C#', 'NuGet', 'MSBuild']
			}
		};

		return stacks[projectType] || {
			type: 'General Development Project',
			technologies: ['Various technologies', 'Project-specific tools']
		};
	}

	// Get common commands for project type
	function getCommonCommandsForProjectType(projectType: string): string[] {
		const commands: Record<string, string[]> = {
			'react': ['npm start', 'npm run build', 'npm test', 'npm install'],
			'nextjs': ['npm run dev', 'npm run build', 'npm run start', 'npm install'],
			'vue': ['npm run serve', 'npm run build', 'npm test', 'npm install'],
			'angular': ['ng serve', 'ng build', 'ng test', 'npm install'],
			'nodejs': ['npm start', 'npm run dev', 'npm test', 'npm install'],
			'nodejs-express': ['npm start', 'npm run dev', 'npm test', 'npm install'],
			'vscode-extension': ['npm run compile', 'npm run watch', 'npm run test', 'F5 (Debug)'],
			'python': ['python main.py', 'pip install -r requirements.txt', 'pytest', 'python -m venv venv'],
			'rust': ['cargo run', 'cargo build', 'cargo test', 'cargo check'],
			'go': ['go run .', 'go build', 'go test', 'go mod tidy'],
			'java': ['mvn spring-boot:run', 'mvn clean install', 'mvn test', 'gradle build'],
			'dotnet': ['dotnet run', 'dotnet build', 'dotnet test', 'dotnet restore']
		};

		return commands[projectType] || ['[Add project-specific commands]'];
	}

	// Build session startup prompt that references Session_starter.md
	async function buildSessionStartupPrompt(): Promise<string> {
		return `#file:Session_starter.md

üéØ **Session Context Loaded**

I've attached the Session_starter.md file which contains the project context and current state for this session. Please:

1. **Review the session file** for project overview, current status, and established patterns
2. **Follow the documented technical decisions** and architectural patterns
3. **Update the session file** as we make progress with new discoveries and achievements
4. **Maintain project continuity** by building upon previous session work

Ready to continue where we left off! üöÄ`;
	}

	// Enhanced startChat command that handles session continuity setup
	async function enhancedStartChat(): Promise<void> {
		if (state.isExecuting) {
			console.log('‚è≥ Already executing, skipping...');
			return;
		}

		state.isExecuting = true;

		try {
			const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
			if (!workspaceFolder) {
				vscode.window.showErrorMessage('No workspace folder open. Please open a project folder first.');
				return;
			}

			console.log('üöÄ Starting enhanced Chat Catalyst...');

			// Check if this is a new project setup
			const hasCustomInstructions = await checkCustomInstructions();
			const sessionStarterPath = path.join(workspaceFolder.uri.fsPath, 'Session_starter.md');
			let sessionStarterExists = fs.existsSync(sessionStarterPath);

			const setupChanges: string[] = [];

			// Always create/update custom instructions to reflect template changes
			await createCustomInstructions();
			if (!hasCustomInstructions) {
				setupChanges.push('Created .github/copilot-instructions.md for session continuity');
			} else {
				setupChanges.push('Updated .github/copilot-instructions.md with latest template');
			}

			// Create Session_starter.md if missing (don't overwrite existing)
			if (!sessionStarterExists) {
				const projectType = await detectProjectType();
				await createSessionStarter(projectType);
				setupChanges.push(`Created Session_starter.md template for ${projectType} project`);
				sessionStarterExists = true; // Update flag since we just created it
			}

			// Show setup confirmation if we created files
			if (setupChanges.length > 0) {
				const message = `üéØ Session Continuity Setup Complete!\n\n${setupChanges.join('\n')}\n\nYour project now has persistent AI memory across sessions!`;
				vscode.window.showInformationMessage(message);
			}

			// Open Copilot Chat
			await vscode.commands.executeCommand('workbench.panel.chat.view.copilot.focus');
			await new Promise(resolve => setTimeout(resolve, 500));

			// Always prioritize session startup prompt if Session_starter.md exists or was just created
			if (sessionStarterExists) {
				console.log('üéØ Using session startup prompt - Session_starter.md exists');
				const promptToUse = await buildSessionStartupPrompt();
				const success = await injectPromptToChat(promptToUse);
				if (!success) {
					vscode.window.showWarningMessage('Failed to inject session startup prompt. Chat might not be focused.');
				} else {
					console.log('‚úÖ Session startup prompt injected successfully');
				}
			} else {
				// Fallback to old auto-prompt logic only if no Session_starter.md
				console.log('üìã No Session_starter.md found, falling back to auto-prompt logic');
				const autoPrompt = getAutoPrompt();

				if (autoPrompt && autoPrompt.length > 1000) {
					// Use existing long prompt logic
					const success = await injectSmartPrompt();
					if (!success) {
						vscode.window.showWarningMessage('Failed to inject prompt. Chat might not be focused.');
					}
				} else if (autoPrompt) {
					// Use short auto-prompt
					const success = await injectPromptToChat(autoPrompt);
					if (!success) {
						vscode.window.showWarningMessage('Failed to inject auto-prompt. Chat might not be focused.');
					}
				} else {
					// No auto-prompt configured
					vscode.window.showInformationMessage('Chat Catalyst activated! Configure an auto-prompt in settings or create a Session_starter.md file.');
				}
			}

		} finally {
			createManagedTimer(() => {
				state.isExecuting = false;
			}, 1000);
		}
	}

	// Helper function to inject any prompt to chat
	async function injectPromptToChat(prompt: string): Promise<boolean> {
		try {
			// Focus chat and wait
			await vscode.commands.executeCommand('workbench.panel.chat.view.copilot.focus');
			await new Promise(resolve => setTimeout(resolve, 300));

			// Type the prompt
			await vscode.commands.executeCommand('type', { text: prompt });
			console.log(`üìù Injected prompt (${prompt.length} characters)`);

			return true;
		} catch (error) {
			console.error('‚ùå Failed to inject prompt:', error);
			return false;
		}
	}
}

export function deactivate() {
	console.log('üßπ Chat Catalyst is deactivating, cleaning up resources...');
	// Cleanup will be handled by the dispose method registered in activate()
}
