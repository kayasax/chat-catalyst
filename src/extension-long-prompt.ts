import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';

export function activate(context: vscode.ExtensionContext) {
	console.log('üöÄ Chat Catalyst Enhanced with Long Prompt Support is now active!');

	let isExecuting = false;

	// Get extension configuration
	function getConfig() {
		return vscode.workspace.getConfiguration('chatCatalyst');
	}

	// Check if auto-injection is enabled and get the custom prompt
	function getAutoPrompt(): string | null {
		const config = getConfig();
		const enabled = config.get<boolean>('enabled', true);
		const autoPrompt = config.get<string>('autoPrompt', '');

		return enabled && autoPrompt ? autoPrompt : null;
	}

	// Create a context file for very long prompts
	async function createPromptContextFile(longPrompt: string): Promise<string | null> {
		try {
			const tempDir = path.join(os.tmpdir(), 'chat-catalyst-context');

			// Ensure temp directory exists
			if (!fs.existsSync(tempDir)) {
				fs.mkdirSync(tempDir, { recursive: true });
			}

			const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
			const contextFile = path.join(tempDir, `prompt-context-${timestamp}.md`);

			const formattedContent = `# üß† Chat Context for Session

**Generated:** ${new Date().toLocaleString()}
**Source:** Chat Catalyst Auto-Prompt

---

## Your Instructions

${longPrompt}

---

## Session Starter Template Reference

\`\`\`markdown
# üß† AI Session Starter: Project Memory
This file serves as the persistent memory for the AI assistant across sessions in this workspace. It should be updated regularly to reflect the current state, goals, and progress of the project.

---

## üìò Project Overview
**Project Name:** _Provide a short, descriptive name for the project._
**Description:** _A brief summary of what this project is about, its purpose, and key components._
**Primary Goals:**
- Goal 1
- Goal 2
- Goal 3

**Key Technologies / Tools:** _List any relevant frameworks, libraries, or platforms._

---

## üß† Assistant Memory
This section is maintained by the AI assistant to track important context and decisions across sessions.

**Current Understanding:** _Summary of what the assistant currently knows about the project._

**Known Constraints or Requirements:**
- Constraint 1
- Constraint 2

**Pending Questions / Clarifications:**
- Question 1
- Question 2

---

## üîÑ Update Log
| Date       | Summary of Update                          |
|------------|---------------------------------------------|
| YYYY-MM-DD | Initial project setup and context defined.  |

---

## ‚úÖ Next Steps
- [ ] Task 1
- [ ] Task 2
- [ ] Task 3

---

> _This file is automatically referenced and updated by the AI assistant to maintain continuity across sessions._
\`\`\`

---

*This context file was automatically generated by Chat Catalyst for better long-prompt handling.*
`;

			fs.writeFileSync(contextFile, formattedContent);

			// Schedule cleanup after 1 hour
			setTimeout(() => {
				try {
					if (fs.existsSync(contextFile)) {
						fs.unlinkSync(contextFile);
					}
				} catch (error) {
					console.log('Could not clean up context file:', error);
				}
			}, 60 * 60 * 1000); // 1 hour

			return contextFile;
		} catch (error) {
			console.error('Failed to create context file:', error);
			return null;
		}
	}

	// Get relevant project files for context
	function getRelevantProjectFiles(): string[] {
		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			return [];
		}

		const relevantFiles: string[] = [];
		const basePath = workspaceFolder.uri.fsPath;

		// Check for Session_starter.md in parent directory first, then current
		const sessionStarterPaths = [
			{ path: path.join(basePath, '..', 'Session_starter.md'), ref: '../Session_starter.md' },
			{ path: path.join(basePath, 'Session_starter.md'), ref: 'Session_starter.md' }
		];

		for (const { path: sessionPath, ref } of sessionStarterPaths) {
			if (fs.existsSync(sessionPath)) {
				relevantFiles.push(ref);
				break;
			}
		}

		// Common important files
		const importantFiles = ['README.md', 'package.json', 'tsconfig.json'];
		for (const file of importantFiles) {
			const filePath = path.join(basePath, file);
			if (fs.existsSync(filePath)) {
				relevantFiles.push(file);
			}
		}

		return relevantFiles;
	}

	// Build rich context prompt with smart long-prompt handling
	async function buildSmartContextPrompt(autoPrompt: string): Promise<string> {
		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			return autoPrompt;
		}

		// Check if prompt is very long (over 1000 characters)
		if (autoPrompt.length > 1000) {
			console.log('üîÑ Long prompt detected, creating context file...');

			const contextFile = await createPromptContextFile(autoPrompt);
			if (contextFile) {
				try {				// Try to get relative path to workspace, or use absolute path
				const workspacePath = workspaceFolder.uri.fsPath;

					// If the context file is accessible, use a file reference
					const relevantFiles = getRelevantProjectFiles();
					let richPrompt = '#workspace ';

					// Add existing session starter if available
					const sessionStarter = relevantFiles.find(f => f.includes('Session_starter.md'));
					if (sessionStarter) {
						richPrompt += `#file:${sessionStarter} `;
					}

					// Add the context file (copy to workspace temp for attachment)
					const workspaceContextFile = path.join(workspacePath, '.vscode', `context-${Date.now()}.md`);
					const vscodeDir = path.dirname(workspaceContextFile);

					if (!fs.existsSync(vscodeDir)) {
						fs.mkdirSync(vscodeDir, { recursive: true });
					}

					fs.copyFileSync(contextFile, workspaceContextFile);
					richPrompt += `#file:.vscode/context-${Date.now()}.md `;

					// Clean up workspace context file after some time
					setTimeout(() => {
						try {
							if (fs.existsSync(workspaceContextFile)) {
								fs.unlinkSync(workspaceContextFile);
							}
						} catch (error) {
							console.log('Could not clean up workspace context file:', error);
						}
					}, 30 * 60 * 1000); // 30 minutes

					richPrompt += `

üéØ **Long Prompt Context Loaded**

I've attached a detailed context file with comprehensive instructions for this session. Please:

1. **Review the attached context file** for complete instructions
2. **Follow the step-by-step guidance** provided
3. **Use the session starter template** if creating new files
4. **Maintain continuity** as described in the instructions

Ready to help with your project! üöÄ`;

					return richPrompt;
				} catch (error) {
					console.log('Could not create workspace context file, using fallback:', error);
				}
			}
		}

		// Fallback for shorter prompts or if context file creation fails
		let richPrompt = '#workspace ';
		const relevantFiles = getRelevantProjectFiles();

		// Add session starter if available
		const sessionStarter = relevantFiles.find(f => f.includes('Session_starter.md'));
		if (sessionStarter) {
			richPrompt += `#file:${sessionStarter} `;
		}

		// Add other important files (limit to avoid overload)
		const otherFiles = relevantFiles.filter(f => !f.includes('Session_starter.md')).slice(0, 2);
		for (const file of otherFiles) {
			richPrompt += `#file:${file} `;
		}

		richPrompt += '\n\n' + autoPrompt;
		return richPrompt;
	}

	// Function to clear existing text in chat input field
	async function clearChatInput(): Promise<boolean> {
		try {
			await vscode.commands.executeCommand('editor.action.selectAll');
			await new Promise(resolve => setTimeout(resolve, 50));
			await vscode.commands.executeCommand('deleteLeft');
			return true;
		} catch {
			try {
				await vscode.commands.executeCommand('deleteLeft');
				return true;
			} catch {
				return false;
			}
		}
	}

	// Enhanced injection function with smart prompt handling
	async function injectSmartPrompt(): Promise<boolean> {
		const autoPrompt = getAutoPrompt();
		if (!autoPrompt) { return false; }

		console.log(`üîÑ Processing prompt (${autoPrompt.length} characters)...`);

		try {
			let originalClipboard = '';
			try {
				originalClipboard = await vscode.env.clipboard.readText();
			} catch {
				// Ignore clipboard read errors
			}

			// Clear existing input
			const cleared = await clearChatInput();
			if (!cleared) {
				console.log('‚ö†Ô∏è Could not clear existing text, continuing anyway...');
			}

			await new Promise(resolve => setTimeout(resolve, 10));

			// Build smart context prompt (handles long prompts automatically)
			const smartPrompt = await buildSmartContextPrompt(autoPrompt);

			// Put smart prompt in clipboard
			await vscode.env.clipboard.writeText(smartPrompt);
			await new Promise(resolve => setTimeout(resolve, 10));

			// Inject the prompt
			try {
				await vscode.commands.executeCommand('type', { text: smartPrompt });
				console.log('‚úÖ Smart prompt injected successfully');
				vscode.window.setStatusBarMessage(
					smartPrompt.length > autoPrompt.length ?
					'‚úÖ Enhanced prompt with attachments injected!' :
					'‚úÖ Prompt injected!',
					3000
				);

				// Restore clipboard
				setTimeout(async () => {
					try {
						if (originalClipboard !== undefined) {
							await vscode.env.clipboard.writeText(originalClipboard);
						}
					} catch {
						// Ignore restore errors
					}
				}, 200);
				return true;
			} catch {
				// Fallback to paste
				try {
					await vscode.commands.executeCommand('editor.action.clipboardPasteAction');
					console.log('‚úÖ Smart prompt pasted successfully');
					vscode.window.setStatusBarMessage('‚úÖ Smart prompt pasted!', 2000);
					return true;
				} catch {
					console.log('‚ùå Both type and paste failed');
					return false;
				}
			}
		} catch (error) {
			console.error('‚ùå Smart injection failed:', error);
			vscode.window.setStatusBarMessage('‚ùå Injection failed', 2000);
			return false;
		}
	}

	// Register commands
	const startChatCommand = vscode.commands.registerCommand('chatCatalyst.startChat', async () => {
		if (isExecuting) {
			console.log('‚è≥ Already executing, skipping...');
			return;
		}

		isExecuting = true;

		try {
			const autoPrompt = getAutoPrompt();
			if (!autoPrompt) {
				vscode.window.showInformationMessage('No auto-prompt configured. Use "Edit Auto-Prompt" to set one up.');
				return;
			}

			// Open Copilot Chat
			await vscode.commands.executeCommand('workbench.panel.chat.view.copilot.focus');
			await new Promise(resolve => setTimeout(resolve, 500));

			// Inject smart prompt
			const success = await injectSmartPrompt();
			if (!success) {
				vscode.window.showWarningMessage('Failed to inject prompt. Chat might not be focused.');
			}
		} finally {
			setTimeout(() => {
				isExecuting = false;
			}, 1000);
		}
	});

	// Other commands remain the same...
	const editPromptCommand = vscode.commands.registerCommand('chatCatalyst.editPrompt', async () => {
		const config = getConfig();
		const currentPrompt = config.get<string>('autoPrompt', '');

		const newPrompt = await vscode.window.showInputBox({
			prompt: 'Enter your auto-prompt for Copilot Chat',
			value: currentPrompt,
			placeHolder: 'Your default prompt...'
		});

		if (newPrompt !== undefined) {
			await config.update('autoPrompt', newPrompt, vscode.ConfigurationTarget.Global);
			vscode.window.showInformationMessage('‚úÖ Auto-prompt updated successfully!');
		}
	});

	const toggleCommand = vscode.commands.registerCommand('chatCatalyst.toggle', async () => {
		const config = getConfig();
		const currentEnabled = config.get<boolean>('enabled', true);
		await config.update('enabled', !currentEnabled, vscode.ConfigurationTarget.Global);
		vscode.window.showInformationMessage(`Chat Catalyst ${!currentEnabled ? 'enabled' : 'disabled'}!`);
	});

	context.subscriptions.push(startChatCommand, editPromptCommand, toggleCommand);
}

export function deactivate() {}
