import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';

export function activate(context: vscode.ExtensionContext) {
	console.log('üöÄ Chat Catalyst extension is now active!');

	// Track if we're currently executing to prevent conflicts
	let isExecuting = false;

	// Get extension configuration
	function getConfig() {
		return vscode.workspace.getConfiguration('chatCatalyst');
	}

	// Check if auto-injection is enabled and get the custom prompt
	function getAutoPrompt(): string | null {
		const config = getConfig();
		const enabled = config.get<boolean>('enabled', true);
		const autoPrompt = config.get<string>('autoPrompt', '');

		return enabled && autoPrompt ? autoPrompt : null;
	}

	// Function to detect relevant project files for context
	function getRelevantProjectFiles(): string[] {
		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			return [];
		}

		const relevantFiles: string[] = [];
		const basePath = workspaceFolder.uri.fsPath;

		// Check for Session_starter.md in parent directory first, then current
		const sessionStarterPaths = [
			{ path: path.join(basePath, '..', 'Session_starter.md'), ref: '../Session_starter.md' },
			{ path: path.join(basePath, 'Session_starter.md'), ref: 'Session_starter.md' }
		];

		for (const { path: sessionPath, ref } of sessionStarterPaths) {
			if (fs.existsSync(sessionPath)) {
				relevantFiles.push(ref);
				break; // Use the first one found
			}
		}

		// Common important files to include for context (in current directory)
		const importantFiles = [
			'README.md',
			'package.json',
			'tsconfig.json',
			'angular.json',
			'pom.xml',
			'requirements.txt',
			'Cargo.toml',
			'go.mod',
			'.env.example'
		];

		for (const file of importantFiles) {
			const filePath = path.join(basePath, file);
			if (fs.existsSync(filePath)) {
				relevantFiles.push(file);
			}
		}

		return relevantFiles;
	}

	// Function to create rich context with intelligent file attachments
	function buildRichContextPrompt(autoPrompt: string): string {
		const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
		if (!workspaceFolder) {
			return autoPrompt;
		}

		let richPrompt = '';

		// Always include workspace context for broad understanding
		richPrompt += '#workspace ';

		// Get relevant project files
		const relevantFiles = getRelevantProjectFiles();

		// Add Session_starter.md if it exists (highest priority)
		if (relevantFiles.includes('Session_starter.md')) {
			richPrompt += '#file:Session_starter.md ';
		}

		// Add currently active file if it's a source file (not untitled)
		const activeEditor = vscode.window.activeTextEditor;
		if (activeEditor && !activeEditor.document.isUntitled) {
			const relativePath = vscode.workspace.asRelativePath(activeEditor.document.uri);
			const fileExtension = path.extname(relativePath).toLowerCase();

			// Only include programming files and documentation
			const includedExtensions = ['.ts', '.js', '.py', '.java', '.cs', '.cpp', '.c', '.go', '.rs', '.php', '.rb', '.kt', '.swift', '.scala', '.md', '.json', '.yaml', '.yml', '.xml', '.html', '.css', '.scss', '.less'];

			if (includedExtensions.includes(fileExtension)) {
				richPrompt += `#file:${relativePath} `;
			}
		}

		// Add other relevant project files (max 2 more to avoid overload)
		const otherFiles = relevantFiles
			.filter(file => file !== 'Session_starter.md')
			.slice(0, 2);

		for (const file of otherFiles) {
			richPrompt += `#file:${file} `;
		}

		// Add the actual prompt with clear separation
		richPrompt += '\n\n' + autoPrompt;

		// If prompt is very long, suggest creating a context file
		if (autoPrompt.length > 2000) {
			richPrompt = richPrompt.replace(autoPrompt,
				autoPrompt + '\n\nüìé Note: This is a detailed prompt. All relevant project files are attached above for full context.'
			);
		}

		return richPrompt.trim();
	}

	// Enhanced function to create dynamic context files for very long prompts
	async function createContextFileIfNeeded(prompt: string): Promise<string | null> {
		// Only create context file for very long prompts (>5000 chars)
		if (prompt.length < 5000) {
			return null;
		}

		try {
			const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
			if (!workspaceFolder) {
				return null;
			}

			const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
			const contextFileName = `context-prompt-${timestamp}.md`;
			const contextFilePath = path.join(workspaceFolder.uri.fsPath, contextFileName);

			const contextContent = `# Chat Context - ${new Date().toLocaleDateString()}

## Long Prompt Content

${prompt}

---
*This file was auto-generated by Chat Catalyst for a long prompt. You can delete it after your chat session.*
`;

			await fs.promises.writeFile(contextFilePath, contextContent, 'utf8');

			// Return shortened prompt that references the file
			return `#workspace #file:Session_starter.md #file:${contextFileName}

I've created a detailed context file (${contextFileName}) with my full prompt. Please review it along with the session starter and help me continue my work.

Key points from my request:
${prompt.substring(0, 300)}...

Full details are in the attached context file.`;

		} catch (error) {
			console.log('Could not create context file:', error);
			return null;
		}
	}
	// Enhanced injection function with rich context support
	async function clearChatInput(): Promise<boolean> {
		// console.log('üßπ Clearing existing chat input text...');

		try {
			// Method 1: Select all and delete
			try {
				await vscode.commands.executeCommand('editor.action.selectAll');
				await new Promise(resolve => setTimeout(resolve, 50));
				await vscode.commands.executeCommand('deleteLeft');
				// console.log('‚úÖ Text cleared via selectAll + delete');
				return true;			} catch {
				// console.log('Method 1 failed, trying method 2');
			}

			// Method 2: Ctrl+A then Delete
			try {
				await vscode.commands.executeCommand('editor.action.selectAll');
				await new Promise(resolve => setTimeout(resolve, 50));
				await vscode.commands.executeCommand('deleteRight');
				// console.log('‚úÖ Text cleared via selectAll + deleteRight');
				return true;			} catch {
				// console.log('Method 2 failed, trying method 3');
			}

			// Method 3: Just try to clear with escape then delete
			try {
				await vscode.commands.executeCommand('workbench.action.chat.cancel');
				await new Promise(resolve => setTimeout(resolve, 50));
				// console.log('‚úÖ Text cleared via chat cancel');
				return true;			} catch {
				// console.log('Method 3 failed');
				return false;
			}

		} catch {
			// console.log('‚ùå All clear methods failed');
			return false;
		}
	}

	// Enhanced injection function with rich context support
	async function injectAutoPrompt(): Promise<boolean> {
		const autoPrompt = getAutoPrompt();
		if (!autoPrompt) { return false; }

		try {
			// Check if we need to create a context file for very long prompts
			const contextFilePrompt = await createContextFileIfNeeded(autoPrompt);

			// Build rich context with file attachments
			const finalPrompt = contextFilePrompt || buildRichContextPrompt(autoPrompt);

			console.log('üîÑ Injecting enhanced prompt with attachments...');

			// Store original clipboard with better error handling
			let originalClipboard = '';
			try {
				originalClipboard = await vscode.env.clipboard.readText();
			} catch {
				// console.log('‚ö†Ô∏è Could not read clipboard, continuing anyway...');
			}

			// Step 1: Clear any existing text in the input field
			// console.log('üßπ Clearing existing text...');
			const cleared = await clearChatInput();
			if (!cleared) {
				// console.log('‚ö†Ô∏è Could not clear existing text, continuing anyway...');
			}

			// Minimal delay after clearing (reduced to 10ms)
			await new Promise(resolve => setTimeout(resolve, 10));

			// Step 2: Put enhanced prompt in clipboard
			await vscode.env.clipboard.writeText(finalPrompt);

			// Faster delay for better responsiveness (reduced to 10ms)
			await new Promise(resolve => setTimeout(resolve, 10));

			// Step 3: Try type command first (most reliable when input is focused)
			try {
				await vscode.commands.executeCommand('type', { text: finalPrompt });

				console.log('‚úÖ Enhanced prompt with attachments injected successfully');
				vscode.window.setStatusBarMessage('‚úÖ Rich prompt injected!', 2000);

				// Fast clipboard restore after success
				setTimeout(async () => {
					try {
						if (originalClipboard !== undefined) {
							await vscode.env.clipboard.writeText(originalClipboard);
						}
					} catch {
						// console.log('‚ö†Ô∏è Could not restore clipboard:', restoreError);
					}
				}, 200);
				return true;
			} catch {
				// console.log('Type failed, trying paste:', typeError);

				// Step 4: Fallback to paste
				try {
					await vscode.commands.executeCommand('editor.action.clipboardPasteAction');

					console.log('‚úÖ Enhanced prompt injected via paste');
					vscode.window.setStatusBarMessage('‚úÖ Rich prompt injected!', 2000);

					// Restore clipboard after successful paste
					setTimeout(async () => {
						try {
							if (originalClipboard !== undefined) {
								await vscode.env.clipboard.writeText(originalClipboard);
							}
						} catch {
							// console.log('‚ö†Ô∏è Could not restore clipboard:', restoreError);
						}
					}, 200);
					return true;
				} catch {
					// console.log('Paste also failed:', pasteError);
					vscode.window.setStatusBarMessage('‚ùå Injection failed', 2000);
					return false;
				}
			}
		} catch (error) {
			console.error('‚ùå Enhanced injection failed:', error);
			vscode.window.setStatusBarMessage('‚ùå Injection failed', 2000);
			return false;
		}
	}

	// Create a chat handler that auto-injects the custom prompt
	const handler: vscode.ChatRequestHandler = async (request: vscode.ChatRequest, context: vscode.ChatContext, stream: vscode.ChatResponseStream, _token: vscode.CancellationToken) => {

		const autoPrompt = getAutoPrompt();
		if (!autoPrompt) {
			stream.markdown('No auto-prompt configured. Use "Chat Catalyst: Edit Auto-Prompt" to set one up.');
			return;
		}

		try {
			// Try to inject the prompt into the main chat
			const success = await injectAutoPrompt();
			if (success) {
				stream.markdown('‚úÖ Auto-prompt injected into main chat! You can now continue your conversation there.');
			} else {
				stream.markdown('‚ö†Ô∏è Could not inject into main chat. Here\'s your prompt:\n\n' + autoPrompt);
			}
		} catch (error) {
			stream.markdown('‚ùå Error: ' + (error as Error).message);
		}
	};

	// Register the chat participant
	const catalyst = vscode.chat.createChatParticipant('catalyst', handler);
	catalyst.iconPath = vscode.Uri.joinPath(context.extensionUri, 'tutor.jpeg');

	// Command to start chat with auto-prompt injection
	const startChatCommand = vscode.commands.registerCommand('chatCatalyst.startChat', async () => {
		if (isExecuting) {
			console.log('‚ö†Ô∏è Already executing, skipping...');
			return;
		}

		isExecuting = true;

		try {
			const autoPrompt = getAutoPrompt();
			if (!autoPrompt) {
				vscode.window.showWarningMessage(
					'No auto-prompt configured. Set one up first!',
					'Configure Prompt'
				).then(selection => {
					if (selection === 'Configure Prompt') {
						vscode.commands.executeCommand('chatCatalyst.editPrompt');
					}
				});
				return;
			}

			console.log('üöÄ Starting chat with enhanced prompt injection...');

			// Try to open chat first, then inject
			try {
				// Opening GitHub Copilot Chat
				await vscode.commands.executeCommand('github.copilot.chat.open');
				console.log('‚úÖ Chat opened successfully');

				// Small delay to let chat fully load
				await new Promise(resolve => setTimeout(resolve, 200));

				// Focus chat and inject enhanced prompt
				try {
					await vscode.commands.executeCommand('github.copilot.chat.focus');
					await new Promise(resolve => setTimeout(resolve, 100));

					console.log('‚úÖ Chat focused, injecting enhanced prompt...');
					const success = await injectAutoPrompt();

					if (success) {
						console.log('üéâ Enhanced prompt injection complete!');
						vscode.window.setStatusBarMessage('üéâ Ready to chat with full context!', 3000);
					} else {
						vscode.window.showWarningMessage('Prompt injection failed. Try clicking in the chat input first.');
					}
				} catch (focusError) {
					console.log('Focus failed, trying direct injection:', focusError);
					const success = await injectAutoPrompt();
					if (!success) {
						vscode.window.showWarningMessage('Could not inject prompt. Click in chat input and press Ctrl+Alt+C again.');
					}
				}
			} catch (openError) {
				console.log('Could not open chat automatically:', openError);
				vscode.window.showWarningMessage(
					'Could not open chat automatically. Please open GitHub Copilot Chat manually and try again.',
					'Open Chat'
				).then(selection => {
					if (selection === 'Open Chat') {
						vscode.commands.executeCommand('github.copilot.chat.open');
					}
				});
			}
		} finally {
			// Always reset the execution flag after delay
			setTimeout(() => {
				isExecuting = false;
			}, 1000);
		}
	});

	// Command to edit the auto-prompt
	const editPromptCommand = vscode.commands.registerCommand('chatCatalyst.editPrompt', async () => {
		const config = getConfig();
		const currentPrompt = config.get<string>('autoPrompt', '');

		const newPrompt = await vscode.window.showInputBox({
			prompt: 'Enter your auto-prompt for Chat Catalyst',
			value: currentPrompt,
			placeHolder: 'Example: You are an expert TypeScript developer. Help me with...',
			ignoreFocusOut: true
		});

		if (newPrompt !== undefined) {
			await config.update('autoPrompt', newPrompt, vscode.ConfigurationTarget.Global);
			vscode.window.showInformationMessage('‚úÖ Auto-prompt updated successfully!');
		}
	});

	// Command to toggle the extension
	const toggleCommand = vscode.commands.registerCommand('chatCatalyst.toggle', async () => {
		const config = getConfig();
		const currentEnabled = config.get<boolean>('enabled', true);
		const newEnabled = !currentEnabled;

		await config.update('enabled', newEnabled, vscode.ConfigurationTarget.Global);

		const status = newEnabled ? 'enabled' : 'disabled';
		vscode.window.showInformationMessage(`‚úÖ Chat Catalyst ${status}!`);
	});

	// Test command for development
	const testCommand = vscode.commands.registerCommand('chatCatalyst.test', async () => {
		const autoPrompt = getAutoPrompt();
		if (autoPrompt) {
			const enhanced = buildRichContextPrompt(autoPrompt);
			console.log('Enhanced prompt:', enhanced);
			vscode.window.showInformationMessage('Enhanced prompt logged to console. Check Developer Tools.');
		} else {
			vscode.window.showWarningMessage('No auto-prompt configured.');
		}
	});

	// Debug command to show current configuration and context
	const debugCommand = vscode.commands.registerCommand('chatCatalyst.debug', async () => {
		const config = getConfig();
		const enabled = config.get<boolean>('enabled', true);
		const autoPrompt = config.get<string>('autoPrompt', '');
		const relevantFiles = getRelevantProjectFiles();

		const debugInfo = `
Chat Catalyst Debug Info:
- Enabled: ${enabled}
- Auto-prompt length: ${autoPrompt.length} characters
- Relevant project files: ${relevantFiles.join(', ') || 'None found'}
- Workspace folders: ${vscode.workspace.workspaceFolders?.length || 0}
- Active editor: ${vscode.window.activeTextEditor ? vscode.workspace.asRelativePath(vscode.window.activeTextEditor.document.uri) : 'None'}
		`.trim();

		console.log(debugInfo);

		vscode.window.showInformationMessage(
			'Debug info logged to console. Check Developer Tools.',
			'Show Details'
		).then(selection => {
			if (selection === 'Show Details') {
				vscode.window.showInformationMessage(debugInfo);
			}
		});
	});

	// Register all commands
	context.subscriptions.push(startChatCommand, editPromptCommand, toggleCommand, testCommand, debugCommand);

	// Welcome message with setup help
	const config = getConfig();
	const hasPrompt = config.get<string>('autoPrompt', '').length > 0;

	if (!hasPrompt) {
		vscode.window.showInformationMessage(
			'üöÄ Chat Catalyst is ready! Set up your auto-prompt to get started.',
			'Set Up Prompt',
			'Learn More'
		).then(selection => {
			if (selection === 'Set Up Prompt') {
				vscode.commands.executeCommand('chatCatalyst.editPrompt');
			} else if (selection === 'Learn More') {
				vscode.env.openExternal(vscode.Uri.parse('https://marketplace.visualstudio.com/items?itemName=LoicMICHEL.chat-catalyst'));
			}
		});
	}
}

export function deactivate() {
	console.log('üëã Chat Catalyst extension deactivated');
}
